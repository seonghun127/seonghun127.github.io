<!DOCTYPE html><html><head><meta charset="UTF-8"><title> Spring Event 2 </title><meta name="viewport" content="width=device-width, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="shortcut icon" href="/favicon.a35c33cf.ico" type="image/x-icon"><link rel="stylesheet" href="/init.366dd74d.css"><link rel="stylesheet" href="/article.3478855a.css"></head><body> <header id="top-container" role="navigation"> </header> <main id="main-container"> <article id="article-container"> <h1 id="article-title"> Spring Event 2 </h1> <h2 id="article-subtitle"> spring event를 적용해보면서 했던 삽질 2 </h2> <time id="article-date"> 2020.05.03 </time> <section id="article-content-container"> <h1>Spring Event-2</h1>
<p><em>이 글은 <a href="https://seonghun127.github.io/article/9.html">Spring Event 1</a> 글과 이어지는 내용입니다. 이전 글을 읽지 않으신 분은 앞선 글을 읽으셔야 아래 내용이 이해되실겁니다.</em></p>
<p>이제 새로운 조건이 생겼다.</p>
<p><code>count</code>가 100 이상인 <code>Member</code>에 경우에만 이벤트가 이를 구독하여 <code>count</code>를 1증가시켜야한다.</p>
<p>사실 이벤트 구독 시 조건을 추가하는 것은 매우 쉬운 일이다.</p>
<p>조건을 추가해보자.</p>
<p>아래와 같이 <code>@TransactionalEventListener</code>에 condition을 추가해주자.</p>
<pre class="hljs"><code><span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberEventSubscriber</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MemberIncreaseService memberIncreaseService;

    <span class="hljs-meta">@TransactionalEventListener</span>(condition = <span class="hljs-string">"#memberEvent.member.count &gt;= 100"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processEvent</span><span class="hljs-params">(MemberEvent memberEvent)</span> </span>{
        log.info(<span class="hljs-string">"Event received! {}"</span>, memberEvent.toString());
        memberIncreaseService.increase(memberEvent.getMember());
    }
}
</code></pre>
<p>condition 값으로 들어간 <code>&quot;#memberEvent.member.count &gt;= 100&quot;</code> 는 SqEL 이다.</p>
<p>SpEL에 대해 간단하게 정리하자면 런타임 시에 객체에 접근할 수 있는 유용한 언어다. 여기서 사용한 <code>&quot;#memberEvent.member.count &gt;= 100&quot;</code> 을 하나씩 해석해보면</p>
<ol>
<li>이벤트 구독 메서드인 <code>processEvent()</code>의 파라미터로 선언된 <code>memberEvent</code>에 <code>#memberEvent</code>로 접근한다.</li>
<li>해당 인스턴스가 가지고 있는 <code>getMember()</code>를 <code>.member</code>로 호출해서 실제 <code>memberEvent</code> 이벤트 객체 안에 있는 회원 <code>member</code> 객체를 꺼낸다.</li>
<li>그런 뒤 <code>member</code> 객체가 가지고 있는 <code>getCount()</code> 메서드를 <code>.count</code>로 호출하여 그 안에 값을 주어진 100 숫자와 크기 비교를 한다.</li>
</ol>
<p>그래서 위 조건이 true 인 경우에만 이벤트를 구독하는 <code>processEvent()</code> 메서드가 실행된다.</p>
<p>SpEL 문법을 잘 몰라도 사실 어느정도 추론이 가능하다고 생각한다. SpEL에 대해서는 <a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">레퍼런스</a>를 참고하길 바란다.</p>
<p>이제 간단하게 테스트 해볼 수 있게 새로운 API를 하나 만들어보자.</p>
<p><code>PathVariable</code>로 전달하는 숫자만큼의 <code>count</code> 를 가지는 <code>Member</code> 생성 API이다.</p>
<pre class="hljs"><code><span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberEventService</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MemberRepository memberRepository;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationEventPublisher applicationEventPublisher;

    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>{
        Member member = memberRepository.save(Member.builder()
                .count(<span class="hljs-number">100</span>)
                .build());

        publishEvent(member);
    }

	<span class="hljs-comment">// 새로 추가한 메서드</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveBy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{
        Member member = memberRepository.save(Member.builder()
                .count(count)
                .build());

        publishEvent(member);
    }

		...
	<span class="hljs-comment">// publishEvent() 생략</span>
}
</code></pre>
<pre class="hljs"><code><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberController</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MemberEventService memberEventService;

    <span class="hljs-meta">@GetMapping</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">()</span> </span>{
        memberEventService.save();
    }

	<span class="hljs-comment">// 회원의 count를 인자로 받아서 새롭게 생성하는 API다.</span>
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/members/{count}"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishMemberEvent</span><span class="hljs-params">(@PathVariable <span class="hljs-keyword">int</span> count)</span> </span>{
        memberEventService.saveBy(count);
    }
}
</code></pre>
<p>해당 API를 100이상의 인자로 호출 시에는 새롭게 생성된 회원의 count 값이 1 증가하는 것을 확인할 수 있고 99 이하의 숫자를 인자로 전달한 경우에는 회원은 새롭게 생성되지만 count 값이 1 증가하지 않는 것을 확인할 수 있다.</p>
<p><em>PathVariable로 100을 전달한 경우</em></p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915448-673a4a80-8d8d-11ea-9320-ce1208036982.png" alt=""></p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915450-6b666800-8d8d-11ea-82db-bce5f3f51b17.png" alt=""></p>
<p><em>PathVariable로 99를 전달한 경우</em></p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915451-6dc8c200-8d8d-11ea-86e7-fdbf58241cbb.png" alt=""></p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915453-6f928580-8d8d-11ea-8885-9b71137fd87a.png" alt=""></p>
<p>이렇게 우리는 SpEL 로 이벤트 구독의 새로운 조건을 쉽게 추가해줬다.</p>
<p>그러면 이제 이벤트를 구독하는 <code>MemberEventSubscriber</code> 의 테스트 코드를 작성해보자.</p>
<p>이벤트 구독자를 어떻게 테스트를 할 수 있을까 고민해보다가 생각한 방법은 mockito를 사용하여 이벤트가 발행한 시점에 <code>MemberEventSubscriber</code>의 <code>processEvent()</code> 메서드의 인자로 전달된 이벤트 객체가 실제 발행된 이벤트와 같은 지를 비교하는 방식으로 구현하기로 했다.</p>
<pre class="hljs"><code><span class="hljs-meta">@SpringBootTest</span>(classes = MemberEventSubscriber.class)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberEventSubscriberTest</span> </span>{

    <span class="hljs-meta">@MockBean</span>
    <span class="hljs-keyword">private</span> MemberEventSubscriber memberEventSubscriber;              <span class="hljs-comment">// 1</span>

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ApplicationEventPublisher applicationEventPublisher;      <span class="hljs-comment">// 2</span>

    <span class="hljs-meta">@Captor</span>
    <span class="hljs-keyword">private</span> ArgumentCaptor&lt;MemberEvent&gt; argumentCaptor;               <span class="hljs-comment">// 3</span>

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 이벤트_발행_시_제대로_구독하는지_테스트() {
        <span class="hljs-comment">// 1. Given</span>
        Member member = Member.builder()
                .count(<span class="hljs-number">100</span>)
                .build();
        MemberEvent event = MemberEvent.builder()
                .member(member)
                .build();

        <span class="hljs-comment">// 2. When</span>
        applicationEventPublisher.publishEvent(event);

        <span class="hljs-comment">// 3. Then</span>
        verify(memberEventSubscriber, times(<span class="hljs-number">1</span>)).processEvent(argumentCaptor.capture());            <span class="hljs-comment">// 4</span>
        MemberEvent publishedEvent = argumentCaptor.getValue();
        assertThat(publishedEvent).isEqualTo(event);
    }
}
</code></pre>
<ol>
<li>조금은 어색할 수 도 있지만 실제 테스트할 <code>MemberEventSubscriber</code> 를 목킹했다. 이 이유는 나중에 <code>verify()</code>로 해당 객체를 확인하기 위함이다. 목킹했더라도 해당 클래스의 인스턴스의 메서드로 들어온 인자를 확인하는데는 전혀 지장이 없기 때문이다.</li>
<li>실제 이벤트를 발행하는 객체다. <code>MemberEventService</code>에서도 이 <code>ApplicationEventPublisher</code> 빈을 주입받아서 이벤트를 발행했기 때문에 테스트에서도 똑같이 이벤트를 발행시키위해 빈으로 주입받는다.</li>
<li><code>mockito</code> 라이브러리에 있는 <code>Captor</code>다. 이 객체를 통해 <code>verify()</code>에서 메서드 인자로 들어온 값을 캡쳐할 수 있다.</li>
<li>본 테스트의 핵심 부분이다. <code>verify()</code>로 테스트하려는 <code>memberEventSubscriber</code> 객체의 실제 실행 횟수와 더불어 <code>processEvent()</code> 메서드의 인자로 들어온 객체를 <code>arguemntCapter.capture()</code>로 캡쳐하고 있다.</li>
</ol>
<p>테스트는 성공적으로 돌아간다.</p>
<p>위 테스트 방식은 복잡해보이지만 사실 매우 간단하다. 실제 테스트할 객체를 목킹한다는게 조금 어색할 수 있지만 이벤트 구독 메서드가 잘 동작하고 있다는 것을 확인할 수 있다.</p>
<p>그럼 이제 새롭게 추가해줬던 조건에 맞게 100 미만의 <code>count</code> 값을 가지는 회원 객체의 경우 이벤트 구독자가 이벤트를 처리하지 않는지 테스트를 해보자.</p>
<pre class="hljs"><code>	<span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 이벤트_조건이_부합하지않은경우_이벤트_처리하지_않는지_테스트() {
        <span class="hljs-comment">// 1. Given</span>
        <span class="hljs-keyword">int</span> notConditionCount = <span class="hljs-number">99</span>;
        Member member = Member.builder()
                .count(notConditionCount)
                .build();
        MemberEvent event = MemberEvent.builder()
                .member(member)
                .build();

        <span class="hljs-comment">// 2. When</span>
        applicationEventPublisher.publishEvent(event);

        <span class="hljs-comment">// 3. Then</span>
        verify(memberEventSubscriber, never()).processEvent(argumentCaptor.capture());
    }
</code></pre>
<p>이 테스트 역시 잘 돌아간다. 99 라는 count 값으로 조건에 부합하지 않는 회원에 대한 이벤트가 발생했을 때 <code>memberEventSubscriber.processEvent()</code> 메서드는 실행되지 않는다는 것을 잘 확인할 수 있다.</p>
<p>테스트까지 순탄하게 완성했지만 문제가 하나 있다.</p>
<p>위 실습 환경은 스프링 부트 2.2.6 인데 실제 문제를 맞닥뜨린 환경은 스프링 부트 1.5.7이었다. 또한 멀티모듈 환경이었다.</p>
<blockquote>
<p>원래는 테스트가 깨질 줄 알고 짠 코드였지만 너무나 잘 돌아가서 당황했다. 분명 마주했던 문제와 코드는 크게 다르지 않았기 때문이다. 그래서 그 당시 환경과 동일한 구조로 바꿔봤다.</p>
</blockquote>
<p>변경한 환경은 이렇다.</p>
<ul>
<li>스프링 부트 버전 변경 : 2.2.6 → 1.5.7</li>
<li>멀티 모듈 환경
<ul>
<li>mutli-module-api 모듈과 multi-module-core 모듈 두개를 만들었다.</li>
<li>multi-module-api
<ul>
<li><code>MemberController</code></li>
<li><code>MemberEventService</code></li>
<li><code>MemberIncreaseService</code></li>
<li><code>MemberEventSubscriber</code></li>
<li><code>MemberEventSubscriberTest</code></li>
</ul>
</li>
<li>multi-module-core
<ul>
<li><code>Member</code></li>
<li><code>MemberRepository</code></li>
<li><code>MemberEvent</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>이렇게 실습 환경을 수정하고 다시 테스트를 돌려봤다.</p>
<p>테스트는 보란듯이 실패했다.</p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915454-70c3b280-8d8d-11ea-9c43-93c1b71d3bc4.png" alt=""></p>
<p>SpEL 에서 <code>member</code> 객체로 접근했던 부분이 null 상태라는 오류메세지다.</p>
<p><strong>이 오류 메세지의 원인을 파악하고 디버깅해보면서 어느 지점에서 발생했는지 파악하기까지 정말 오랜 시간이 걸렸다.</strong></p>
<p>일단 위 문제가 발생한 원인은 클래스가 mocking 될 때 CGLIB, ByteBuddy(Mockito 버전에 따라 다르다.) 라이브러리에 의해 mock 클래스가 해당 클래스를 상속하여 만들어진다.</p>
<p>즉, 위 예시에서 <code>@MockBean</code>어노테이션이 붙은 <code>MemberEventSubscriber</code>클래스를 상속하는 Mocking <code>MemberEventSubscriber</code>가 생성되는 것이다.</p>
<p>그리고 SpEL은 새롭게 생성된 Mocking <code>MemberEventSubscriber</code> 기준으로 파라미터를 확인하며 파싱된다.</p>
<p><code>&quot;#memberEvent.member.count &gt;= 100&quot;</code> 를 보면 런타임 시 <code>MemberEventSubscriber</code>클래스가 가지고 있는 <code>processEvent()</code> 메서드의 파리미터인 <code>memberEvent</code>에 접근하게 된다.</p>
<p>여기서 접근하는 <code>processEvent()</code>메서드는 아까 Mockito에 의해 새롭게 상속하면서 만들어진 Mocking <code>MemberEventSubscriber</code> 클래스의 메서드가 된다.</p>
<blockquote>
<p>여기서 스프링은 해당 메서드의 파리미터 이름을 확인하기 위해 Java의 Reflection을 사용하는 <code>ParameterNameDiscoverer</code> 인터페이스를 사용한다.</p>
</blockquote>
<p>위 오류의 원인을 살펴보자. 해당 테스트를 디버깅하면서 하나씩 확인해본 결과 아래 스크린샷에 나온 지점에 도달할 수 있었다.</p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915456-728d7600-8d8d-11ea-81b3-66f08b945476.png" alt=""></p>
<p>런타임 시에 접근하는 SpEL 특성 상 <code>processEvent(MemberEvent memberEvent)</code> 메서드의 파라미터로 선언된 <code>memberEvent</code> 로 접근하게되는데 막상 접근해보니 해당 메서드의 파리미터 이름은 <code>arg0</code>으로 나와있어 SpEL로 선언된 <code>memberEvent</code>는 알 수 없는 존재가 돼버린 것이다.</p>
<p>다시 스프링 버전을 이전으로 높이고 테스트 디버깅을 해보았다.</p>
<p><img src="https://user-images.githubusercontent.com/59458270/80915457-74573980-8d8d-11ea-8c4b-8e0879719f25.png" alt=""></p>
<p>버전이 올라가면서 <code>StandardReflectionParameterNameDiscoverer</code>내부 코드의 구조는 변경됐지만 로직이 변한 부분은 없다.</p>
<p>디버깅 값을 보니 파리미터의 이름으로 <code>memberEvent</code>라는 것이 확인됐다.</p>
<p>해당 이슈로 버전이 낮은 상태에서 오류가 나고 있음을 확인할 수 있었다.</p>
<p>그러나 해당 이슈에 대해 더 정확한 이유를 파악하려했지만 속시원할만한 이유를 알아내지 못한채 다른 해결 방법을 찾았다.</p>
<blockquote>
<p>속으로 너무 아쉬워 이후에도 계속 찾아보고 mockito 그룹스 메일로도 문의를 해본 상황이다. 😭</p>
</blockquote>
<p>그럼 위 버전을 사용하는 사람들이 나와 같은 문제에 시간을 허비하는 일이 없도록 해결방안에 대해 설명해보겠다.</p>
<p>사실 매우 간단하다.</p>
<p>위 문제는 런타임 시 Mocking된 메서드의 파라미터 이름으로 SpEL을 파싱할 수 없으니 발생한 것이다. 꼭 해당 메서드의 파라미터 이름으로 접근하는 방법이 아닌 <code>root</code>라는 것을 이용해 현재 발행된 이벤트에 대해 접근하는 방식으로 해결해보겠다.</p>
<p><code>@TransactionalEventListener(condition = &quot;#root.args[0].member.count &gt;= 100&quot;)</code></p>
<p>condition에 SpEL을 위와같이 작성해주면 된다. 테스트는 정상적으로 동작할 것이다.</p>
<p>하나씩 살펴보자.</p>
<ul>
<li>
<p><code>root</code>라는 것은 <code>EventExpressionRootObject</code> 를 가리킨다. 이 클래스는 이벤트가 발행되는 시점에 타겟이 되는 메서드의 정보를 바탕으로 만들어지는 이벤트 루트 객체다. 여기서 타겟이 되는 메서드는 <code>MemberEventSubscriber</code> 클래스의 <code>processEvent()</code> 메서드를 말한다.</p>
<p>이 객체는 <code>EventExpressionEvaluator</code> 클래스가 만들어주는데 생성자 파라미터 인자로 넘겨주는 것은 두 가지다.</p>
<ol>
<li><code>ApplicationEvent</code> : 발행된 이벤트의 상위 인터페이스다. 실제 발행된 <code>MemberEvent</code>는 <code>PayLoadApplicationEvent</code> 라는 구현체에 담겨 전달된다.</li>
<li><code>args</code> : 타겟 메서드의 파리미터로 선언된 순서대로 발행된 이벤트가 배열에 담겨있다. 이벤트 타겟 메서드의 파라미터는 해당 메서드가 구독할 이벤트의 종류를 나타내기 때문이다. 위 실습에서는 타겟 메서드의 파리미터는 하나이기 때문에 <code>args</code> 배열의 길이는 1이며 <code>MemberEvent</code> 하나가 담기게 된다.</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/59458270/80915459-76b99380-8d8d-11ea-8067-b2bf93a1bcf9.png" alt=""></p>
</li>
<li>
<p><code>root</code>가 의미하는 <code>EventExpressionRootObject</code>에는 <code>getArgs()</code> 메서드가 있다. 해당 객체가 가지고 있는 이벤트 종류를 인덱스로 가져올 수 있다. 그래서 <code>.args[0]</code>은 현재 타겟 메서드의 파리미터로 하나 선언된 <code>MemberEvent</code> 를 가져오겠다는 뜻이다. 만약 타겟 메서드의 파리미터로 여러개가 선언되어 있다면 선언된 순서에 맞게 인덱스로 접근할 수 있다.</p>
</li>
<li>
<p>그렇게 꺼낸 <code>MemberEvent</code>의 <code>.member</code> 를 꺼내고 <code>.count</code> 꺼내는 방식으로 SpEL은 작동할 것이다.</p>
</li>
</ul>
<p><code>@TransactionalEventListener(condition = &quot;#root.event.payload.member.count &gt;= 100&quot;)</code></p>
<p>위와 같이 선언해도 문제없이 돌아간다.</p>
<p><code>root.event.payloay</code>는 <code>EventExpressionRootObject</code>에 생성자 인자로 같이 전달됐던 <code>PayLoadApplicationEvent</code>으로 접근하게 되는 것이다. 그래서 <code>PayLoadApplicationEvent</code> 객체가 가지고 있는 <code>getPayLoad()</code>로 <code>MemberEvent</code>를 가져올 수 있다.</p>
<pre class="hljs"><code>	<span class="hljs-meta">@TransactionalEventListener</span>(condition = <span class="hljs-string">"#root.args[0].member.count &gt;= 100"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processEvent</span><span class="hljs-params">(MemberEvent memberEvent)</span> </span>{
        log.info(<span class="hljs-string">"Event received! {}"</span>, memberEvent.toString());
        memberIncreaseService.increase(memberEvent.getMember());
    }
</code></pre>
<p>하지만 위와 같은 방식이 더 좋다고 생각한다. 이벤트 구독 메서드의 파리미터가 여러개라면 선언된 순서로 인덱스 접근하는 방식이 더 명확하게 느껴지기 때문이다.</p>
<p>정리해보자면, <code>@EventListener</code>와 <code>@TransactionalEventListener</code>어노테이션에는 condition이라는 속성이 존재하여 SpEL로 조건을 줄 수 있다. 특정 조건의 이벤트가 발행됐을 경우에만 구독하는 조건적 이벤트 구독자를 쉽게 만들 수 있다.</p>
<p>그리고 만약 EventListeter 클래스를 테스트하고자 Mocking할 경우 Mocking 과정에 (바이트 코드를 조작하는 CGLIB, Byte Buddy의) 버전 이슈가 있어 타켓 메서드에 선언된 파라미터 이름에 접근하지 못하는 경우가 발생할 수 있다. 최신 버전을 사용하고 있다면 상관없겠지만 Spring Boot 버전이 1.X.X라면 해당 문제를 조심해야한다.</p>
<p>SpEL로 런타임 시 발행된 이벤트 객체에 접근하는 방법은 크게 두가지가 있다.</p>
<ul>
<li>하나는 타겟 메서드의 파라미터 이름으로 접근하는 방법이 있다. 다른 방법 대비 제일 명확한 장점을 가지지만 mock 객체에서 이름이 <code>arg0</code>와 같이 변할 수 있다는 이슈가 있다.</li>
<li>다른 하나는 타켓 메서드 정보를 바탕으로 생성되는 <code>root</code> 이벤트를 통해 접근하는 방법이 있다. 여기서 <code>root</code> 는 <code>EventExpressionRootObject</code>를 가리키는데 타겟 메서드가 구독할 수 있는 이벤트들의 근원이 되는 이벤트라고 생각하면 된다. 그래서 <code>root</code>는 특정 타겟 메서드 기준 발행된 이벤트의 정보를 모두 가지고 있다. 이때 발행됐거나 발행될 수 있는 이벤트가 여러개라면 타겟 메서드의 파리미터 순서에 따라 인덱스를 매겨 <code>.args[index]</code>로 접근할 수 있다.</li>
</ul>
<p>우리는 첫번째 방법으로 구현했고 테스트 과정에서 문제를 맞이하여 두번째 방식으로 해결했다. 최신 버전의 Spring Boot를 사용한다면 첫번째 방법으로 구현해도 문제되지 않는다.</p>
<p>마지막으로 EventListener를 테스트하기 위해 <code>@SpringBooTest</code>로 테스트 환경을 구축했다. 이는 실제 이벤트 발행하기 위함이다. 하지만 Spring 전체를 테스트를 위해 띄우는건 비효울적이므로 환경을 slice하기 위해 <code>@SpringBootTest(classes=MemberEventListener.class)</code>와 같이 특정 빈만 생성되도록 설정해줬다.</p>
<p>그리고 Mockito 라이브러리의 Captor 기능을 활용하여 이벤트 발행 후 타겟 메서드에 이벤트가 인자로 들어왔는지 캡쳐하여 그 값을 확인하면서 테스트를 진행했다.</p>
<p>이렇게 스프링의 이벤트 발행 / 구독 방식을 예제를 통해 구현해보았고 이를 테스트하는 방법도 같이 살펴봤다.</p>
<p>이 모든 과정에 best pratice가 아닐 수 있지만 처음 이 내용을 접해보는 사람들에게 좀 더 쉽게 다가갈 수 있었으면 좋겠다.</p>
<p><em>내 스스로 이번 실습을 통해 회고를 해보자면…</em></p>
<p>처음 SpEL 시작은 이와같았다.</p>
<p><code>@TransactionalEventListener(condition = &quot;#memberEvent.member.count &gt;= 100&quot;</code></p>
<p>SpEL로 타겟 메서드의 파라미터 이름(<code>memberEvent</code>)을 직접 접근하는 것이 제일 명확하다. 하지만 테스트 코드 작성 중 맞이한 오류때문에 명확하다고 생각한 코드를 수정하게 된 부분에 대해 여러가지 차원에서 아쉬움이 남는다.</p>
<ul>
<li>다른 방식으로 테스트 코드를 짜보려는 시도가 부족했던 점 → 버전 이슈에서 벗어나 더 좋은 방식의 테스트 코드가 있을 수 있는데 현재 방식에 너무 꽂힌 나머지 다른 고민은 많이 하지 못했다.</li>
<li>테스트 코드를 통해 프로덕션 코드에 수정이 일어난 점 → 이 과정 속에서 더 나은 방식의 프로덕션 코드가 됐다면 좋은 현상이지만 더 좋은 코드로 발전했다는 느낌이 들기 보단 문제를 해결하기 위한 다른 방안으로 우회한 느낌이다.</li>
<li>문제 해결하기 위한 시간이 너무 오래 걸린 점 → SpEL을 파싱하지 못하는 문제가 정확히 라이브러리의 어떤 점이 변경되어 안되는 건지 그 이유를 명확하게 파악하지 못했다. 변명에 불과하지만 그 과정에 너무 많은 시간이 할애됐고 여러 일정 문제로 심도있게 파고들지 못했다. 😢</li>
<li>(추가적으로) 모듈 분리는 필요없었다. → 모듈 분리로 다른 모듈에 존재하는 이벤트가 테스트 환경에서 참조되지 못하는 이슈때문은 아닐까라는 생각에 모듈도 분리해봤지만 해당 이슈와는 상관없는 문제였다. 문제의 원인을 보다 제대로 파악 했다면 모듈 분리까지 이어지지 않을 수도 있었다는 아쉬움이 있다.</li>
</ul>
<p>위에서 언급한 아쉬운 점을 이후에는 하지않기 위해 포비가 말하는 <strong>의식적인 연습</strong>을 해야겠다.</p>
<h3>reference</h3>
<ul>
<li><a href="https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2">https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2</a></li>
<li><a href="https://www.baeldung.com/spring-events">https://www.baeldung.com/spring-events</a></li>
<li><a href="https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2">https://github.com/mockito/mockito/wiki/What’s-new-in-Mockito-2</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#xboot-features-testing</a></li>
</ul> </section> <section id="article-navigation"> <div class="article-navigation-item article-navigation-next"> <a href="/article/5.html"> <div class="article-navigation-arrow article-navigation-next">＜</div> <div class="article-navigation-content article-navigation-next"> <p class="article-navigation-title">Spring Redis</p> <p class="article-navigation-subtitle">spring에서 redis 간단한 실습</p> </div> </a> </div> <div class="article-navigation-item article-navigation-prev"> <a href="/article/9.html"> <div class="article-navigation-arrow article-navigation-prev">＞</div> <div class="article-navigation-content article-navigation-prev"> <p class="article-navigation-title">Spring Event 1</p> <p class="article-navigation-subtitle">spring event를 적용해보면서 했던 삽질 1</p> </div> </a> </div> </section> <section id="article-list-button-container"> <a href="/articles.html"> <div id="article-list-button">📚</div> </a> </section> </article> </main> <script defer src="/init.7c7d4dd7.js"></script>
</body></html>